#version 330 core

#define FXAA_EDGE_THRESHOLD_MIN 0.0125 //0.03125 // 1/12
#define FXAA_EDGE_THRESHOLD 0.0125 // 1/8
#define FXAA_SUBPIX_TRIM 0
#define FXAA_SUBPIX_TRIM_SCALE 4
#define FXAA_SUBPIX_GAP 0.5
#define FXAA_SEARCH_STEPS 16
#define FXAA_SEARCH_STEP_SCALE 1.25

out vec4 FragColor;

in vec2 texPos;

uniform sampler2D tex;



uniform float offsetWidth;
uniform float offsetHeight;

float luma(vec3 rgb)
{
	return dot(rgb, vec3(0.299, 0.507, 0.114));
}

void fxaa()
{

    vec3 rgbN = texture(tex, texPos + vec2(0.0, -offsetHeight)).rgb;
    vec3 rgbW = texture(tex, texPos + vec2(-offsetWidth, 0.0)).rgb;
    vec3 rgbE = texture(tex, texPos + vec2(offsetWidth, 0.0)).rgb;
    vec3 rgbS = texture(tex, texPos + vec2(0.0, offsetHeight)).rgb;
    vec3 rgbM = texture(tex, texPos).rgb;

    float lumaN = luma(rgbN);
    float lumaW = luma(rgbW);
    float lumaE = luma(rgbE);
    float lumaS = luma(rgbS);
    float lumaM = luma(rgbM);

    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
    float range = rangeMax - rangeMin;
    float rangeMaxScaled = rangeMax * FXAA_EDGE_THRESHOLD;

    if (range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMaxScaled)) {
		// No edge detected, return the original color
		FragColor = vec4(rgbM, 1.0);
		return;
	} else {
		FragColor = vec4(lumaM, 0, 0, 1.0); 
	}


    vec3 rgbNW = texture(tex, texPos + vec2(-offsetWidth, -offsetHeight)).rgb;
    vec3 rgbNE = texture(tex, texPos + vec2(offsetWidth, -offsetHeight)).rgb;
    vec3 rgbSW = texture(tex, texPos + vec2(-offsetWidth, offsetHeight)).rgb;
    vec3 rgbSE = texture(tex, texPos + vec2(offsetWidth, offsetHeight)).rgb;

    float lumaNW = luma(rgbNW);
    float lumaNE = luma(rgbNE);
    float lumaSW = luma(rgbSW);
    float lumaSE = luma(rgbSE);

    float lumaNS = lumaN + lumaS;
    float lumaWE = lumaW + lumaE;
    float subpixRange = 1.0/range;
    float subpixNWSE = lumaNW + lumaSE;
    float edgeHorizontal1 = (-2.0 * lumaM) + lumaNS;
    float edgeVertical1 = (-2.0 * lumaM) + lumaWE;

    float lumaNESE = lumaNE + lumaSE;
    float lumaNWNE = lumaNW + lumaNE;
    float edgeHorizontal2 = (-2.0 * lumaM) + lumaNESE;
    float edgeVertical2 = (-2.0 * lumaM) + lumaNWNE;

    float lumaNWSW = lumaNW + lumaSW;
    float lumaSWSE = lumaSW + lumaSE;
    float edgeHorizontal3 = (-2.0 * lumaM) + lumaNWSW;
    float edgeVertical3 = (-2.0 * lumaM) + lumaSWSE;

    float edgeHorizontal4 = (abs(edgeHorizontal1) * 2.0) + abs(edgeHorizontal2);
    float edgeVertical4 = (abs(edgeVertical1) * 2.0) + abs(edgeVertical2);

    float edgeHorizontal = abs(edgeHorizontal3) + edgeHorizontal4;
    float edgeVertical = abs(edgeVertical3) + edgeVertical4;

    float subpixNWSWNESE = lumaNWSW + lumaNESE;
    float lengthSign = offsetWidth;
    float subpixA = subpixNWSE * 2.0 + subpixNWSWNESE;

    if(edgeHorizontal < edgeVertical) {
        lumaN = lumaW; 
        lumaS = lumaE;
    }
    if(edgeHorizontal >= edgeVertical) lengthSign = offsetHeight;
    float subpixB = (subpixA * 0.0125) - lumaM;

    float gradientN = lumaN - lumaM;
    float gradientS = lumaS - lumaM;
    float lumaNN = lumaN + lumaM;
    float lumaSS = lumaS + lumaM;
    bool pairN = abs(gradientN) >= abs(gradientS);
    float gradient = max(abs(gradientN), abs(gradientS));
    if (pairN) lengthSign = -lengthSign;
    float subpixC = clamp(abs(subpixB) * subpixRange, 0.0, 1.0);




//    FragColor = vec4((rgbN + rgbW + rgbE + rgbS + rgbM)/ 5.0, 1.0);

}


void main()
{
    vec3 rgbN = texture(tex, texPos + vec2(0.0, -offsetHeight)).rgb;
    vec3 rgbW = texture(tex, texPos + vec2(-offsetWidth, 0.0)).rgb;
    vec3 rgbE = texture(tex, texPos + vec2(offsetWidth, 0.0)).rgb;
    vec3 rgbS = texture(tex, texPos + vec2(0.0, offsetHeight)).rgb;
    vec3 rgbM = texture(tex, texPos).rgb;

    vec3 rgbL = rgbN + rgbW + rgbE + rgbS + rgbM;

    float lumaN = luma(rgbN);
    float lumaW = luma(rgbW);
    float lumaE = luma(rgbE);
    float lumaS = luma(rgbS);
    float lumaM = luma(rgbM);

    float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));
    float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));
    float range = rangeMax - rangeMin;
    if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD))
	{
		// No edge detected, return the original color
		FragColor = vec4(rgbM, 1.0);
        FragColor = vec4(lumaM, lumaM, lumaM, 1.0); 

		return;
    } else {
        FragColor = vec4(lumaM, 0, 0, 1.0); 
	}
    
    vec3 rgbNW = texture(tex, texPos + vec2(-offsetWidth, -offsetHeight)).rgb;
    vec3 rgbNE = texture(tex, texPos + vec2(offsetWidth, -offsetHeight)).rgb;
    vec3 rgbSW = texture(tex, texPos + vec2(-offsetWidth, offsetHeight)).rgb;
    vec3 rgbSE = texture(tex, texPos + vec2(offsetWidth, offsetHeight)).rgb;

    float lumaNW = luma(rgbNW);
    float lumaNE = luma(rgbNE);
    float lumaSW = luma(rgbSW);
    float lumaSE = luma(rgbSE);

    // Calcular as diferenças de luminância
    float deltaX = (lumaNE - lumaNW) * 0.5;
    float deltaY = (lumaSE - lumaSW) * 0.5;

    // Criar o vetor normal
    vec2 normal = normalize(vec2(deltaX, deltaY));

    rgbL += rgbNW + rgbNE + rgbSW + rgbSE;
    rgbL *= vec3(1.0/9.0, 1.0/9.0, 1.0/9.0);




//    float lumaL = (lumaNW + lumaN + lumaNE + lumaW + lumaE + lumaSW + lumaS + lumaSE) / 8.0;
    float lumaL = (lumaN + lumaW + lumaE + lumaS) / 4.0;
    float rangeL = abs(lumaL - lumaM);
    float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;
    blendL= min(FXAA_SUBPIX_GAP, blendL);

    float edgeVert = 
        abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +
	    abs(( 0.5 * lumaW ) + (-1.0 * lumaM) + (0.5  * lumaE )) +
        abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));

    float edgeHorz = 
        abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +
	    abs(( 0.5 * lumaN ) + (-1.0 * lumaM) + (0.5  * lumaS )) +
        abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));

    bool horzSpan = edgeHorz >= edgeVert;
//    if (horzSpan){
//        FragColor = vec4(0.8, 0.6, 0.3, 1.0);
//    } else {
//        FragColor = vec4(0.3, 0.0, 0.8, 1.0);
//    }


    // Determina a direção da borda
    vec2 dir = horzSpan ? vec2(offsetWidth, 0.0) : vec2(0.0, offsetHeight);

    bool donePositiveDirection = false;
    float stepPositiveDirection = 0.0;
    bool doneNegativeDirection = false;
    float stepNegativeDirection = 0.0;
    const int maxSteps = FXAA_SEARCH_STEPS; // Limite de passos para evitar loops infinitos

    for (int i = 1; i <= maxSteps; ++i) {
        vec2 pos = texPos + dir * float(i);
        if (!donePositiveDirection){ 
            float lumaSample1 = luma(texture(tex, pos).rgb);
            if (abs(lumaSample1 - lumaM) > range) {
                stepPositiveDirection = float(i);
                donePositiveDirection = true;
                break;
            }
        }
        if (!doneNegativeDirection){ 
            float lumaSample2 = luma(texture(tex, -pos).rgb);
            if (abs(lumaSample2 - lumaM) > range) {
		        stepNegativeDirection = float(i);
                doneNegativeDirection = true;
		        break;
            }
	    }
    }



//    float edgeThickness = stepNegativeDirection + stepPositiveDirection;
//    float pixelOffset = -min(stepNegativeDirection, stepPositiveDirection) / edgeThickness + 0.5;
//
//    float lumaAverage = (1.0/12.0) * (2.0 * (lumaN + lumaE) + lumaNW + lumaSW + lumaNE + lumaSE);
//
//    float subPixelOffet1 = clamp(abs(lumaAverage - lumaM) / range, 0.0, 1.0);
//    float subPixelOffet2 = (-2.0 * subPixelOffet1 + 3.0) * subPixelOffet1 * subPixelOffet1;
//
//    float finalOffset = max(pixelOffset, subPixelOffet2 * subPixelOffet2);
//
//    vec2 finalUv = texPos;
//
//    if(horzSpan ) {
//		finalUv.x += dir.x * finalOffset;
//	} else {
//		finalUv.y += dir.y * finalOffset;
//	}
//
//    FragColor = vec4(texture(tex, finalUv).rgb, 1.0);

    // Calcula a posição de blend adaptativo
    float blendAmount = blendL * max(stepPositiveDirection, stepNegativeDirection);
    vec2 blendPos = clamp(texPos + dir * blendAmount, 0.0, 1.0);

    // Amostra a cor suavizada
    vec3 rgbBlend = texture(tex, blendPos).rgb;

    // Faz o blend final
    FragColor = vec4(mix(rgbM, rgbBlend, blendL), 1.0);
//    FragColor = vec4(mix(mix(rgbM, rgbBlend, blendL), rgbL, 0.3), 1.0);
//    vec3 finalColor = mix(mix(rgbM, rgbBlend, blendL), rgbL, 0.2);


//
//    FragColor = vec4(
//		(lumaN + lumaW + lumaE + lumaS + lumaM) / 5.0,
//		(lumaN + lumaW + lumaE + lumaS + lumaM) / 5.0,
//		(lumaN + lumaW + lumaE + lumaS + lumaM) / 5.0,
//		1.0
//	);
}
